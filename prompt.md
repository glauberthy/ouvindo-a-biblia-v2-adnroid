Parte 1: Contexto para o "Android Architect (Audio/Media)"Assunto: Guia de Implementação da UI para o app "Ouvindo a Bíblia"Visão Geral do Projeto: Estou na fase de construção da interface do usuário (UI) para meu aplicativo de áudio, "Ouvindo a Bíblia". A arquitetura já foi definida (Modular, Clean, Hilt, Room, Media3, Compose), e agora o foco é traduzir os protótipos de tela em código Jetpack Compose funcional e bem estruturado. O objetivo é criar uma experiência de usuário moderna, reativa e alinhada com as melhores práticas de apps de mídia.Fonte de Dados (API/Schema): A aplicação consumirá um JSON estruturado que contém os Testamentos (AT/NT), os livros da Bíblia e seus respectivos capítulos. Cada livro possui:•nome_formatado: Nome para exibição (ex: "Gênesis").•imagem_url: URL da capa do livro, para ser carregada com Coil.•total_capitulos: Quantidade de capítulos.•Uma lista de capitulos, cada um com sua URL de áudio (.ogg).Requisitos de UI e Telas Planejadas:1.HomeScreen (Dashboard Principal):•Estrutura: Scaffold com TopAppBar e LazyColumn.•Componentes-chave:•Continuar Ouvindo: Um card de destaque mostrando o último capítulo ouvido (dados virão do Room).•Navegação por Testamento: FilterChip para alternar entre "Antigo Testamento" e "Novo Testamento".•Livros Favoritos: Uma LazyRow horizontal com os livros marcados como favoritos.•Grid de Todos os Livros: Uma LazyVerticalGrid exibindo as capas (imagem_url) e os nomes (nome_formatado) de todos os livros.•Mini-Player Persistente: (Futuro) Um BottomSheet no rodapé que controla a mídia ativa.2.BookDetailScreen (Detalhes do Livro e Capítulos):•Estrutura: Scaffold com um CollapsingToolbar que exibe a imagem do livro.•Componentes-chave:•Header: Exibe a capa do livro (imagem_url), nome, e metadados (ex: "Antigo Testamento • 50 Capítulos").•Botão de Ação Principal: Um botão para "Ouvir Tudo", que enfileirará todos os capítulos do livro no Media3.•Lista de Capítulos: Uma LazyColumn com os capítulos, onde cada item deve refletir seu estado de download (Disponível, Baixado, Baixando).3.PlayerScreen (Player Imersivo):•Estrutura: Tela cheia, modal, focada na mídia.•Componentes-chave:•Capa do livro em destaque.•Controles de mídia essenciais: Play/Pause, Avançar/Retroceder 10s, Próximo/Anterior.•Controles avançados: Velocidade de reprodução e Timer (Sleep Timer).•Integração com a fila de reprodução do Media3.Desafios Técnicos Imediatos (Foco da Conversa):•Estrutura da HomeScreen: Como organizar os Composables dentro da LazyColumn para representar as diferentes seções (Continuar Ouvindo, Favoritos, Grid de Livros).•Carregamento de Imagens e Cores Dinâmicas: Usar Coil para carregar as imagens da imagem_url e, idealmente, extrair cores da imagem com a biblioteca Palette para tematizar dinamicamente partes da UI (como o fundo do player).•Gestão de Estado da UI: Implementar o padrão LCE (Loading, Content, Error) em todas as telas, garantindo que a UI reaja corretamente enquanto os dados são carregados da rede ou do cache.•Interatividade e Navegação: Garantir que o clique em um livro no grid da HomeScreen navegue para a BookDetailScreen correspondente, passando o ID do livro como argumento.Objetivo da Conversa: Preciso de orientação passo a passo para construir a HomeScreen usando Jetpack Compose, conectando-a a um ViewModel (que será desenvolvido em paralelo) e garantindo que a estrutura seja escalável para adicionar as funcionalidades de mídia e offline no futuro.Parte 2: Guia de Execução Passo a Passo (Seu Documento de Trabalho)Este guia pode servir como seu checklist. Use-o para focar em uma tarefa de cada vez e discuti-la com seu "Gem" quando tiver dúvidas.Fase 1: Construindo a Estrutura da HomeScreen (UI Estática)O objetivo aqui é ter uma tela visualmente correta, usando dados de exemplo (placeholders), exatamente como você já começou no seu arquivo HomeScreen.kt.•Passo 1.1: Refinar AlbumCardItem:•[ ] Modifique o AlbumCardItem para receber imageUrl: String? e title: String.•[ ] Integre a biblioteca Coil (io.coil-kt:coil-compose) para carregar a imagem. Use AsyncImage.•[ ] Adicione um placeholder e um error state no AsyncImage para uma melhor experiência.•Passo 1.2: Criar a Grid de Livros:•[ ] Substitua a LazyRow de "Tocados recentemente" por uma LazyVerticalGrid.•[ ] Use GridCells.Adaptive(minSize = 120.dp) para que a grid se ajuste a diferentes tamanhos de tela.•[ ] Popule a grid com AlbumCardItem, usando dados de exemplo.•Passo 1.3: Construir a Seção "Continuar Ouvindo":•[ ] Crie um novo Composable chamado ContinueListeningCard.•[ ] Ele deve conter uma imagem (AsyncImage), um título (ex: "Gênesis - Cap. 5"), um subtítulo/progresso e um botão de "Play".•[ ] Adicione este componente no topo da LazyColumn da HomeScreen.•Passo 1.4: Chips de Testamento:•[ ] Adicione uma Row com dois FilterChip (ou AssistChip) para "Antigo Testamento" e "Novo Testamento".•[ ] Por enquanto, a lógica de clique pode ficar vazia (onClick = {}).Fase 2: Conectando a UI ao ViewModel e Dados ReaisO objetivo é substituir os dados estáticos por dados dinâmicos vindos de uma fonte de verdade.•Passo 2.1: Definir o HomeState:•[ ] Crie uma data class HomeState que represente tudo que a tela precisa: isLoading: Boolean, books: List<Book>, error: String?, lastPlayed: Chapter?, etc.•(Pergunta para o Gem: "Qual a melhor estrutura para o HomeState com base no meu JSON e layout?")•Passo 2.2: Criar o HomeViewModel:•[ ] Crie o HomeViewModel e use Hilt (@HiltViewModel) para injetar o Repository.•[ ] Exponha um StateFlow<HomeState> para a UI observar.•[ ] Crie uma função no ViewModel que chama o repositório para buscar os livros e atualiza o StateFlow.•Passo 2.3: Ligar a HomeScreen ao ViewModel:•[ ] Na HomeScreen, descomente a linha viewModel: HomeViewModel = hiltViewModel() e injete o ViewModel.•[ ] Colete o StateFlow como estado do Compose: val state by viewModel.uiState.collectAsState().•[ ] Implemente a lógica LCE:•Se state.isLoading for true, mostre um CircularProgressIndicator.•Se state.error não for nulo, mostre uma mensagem de erro.•Se houver conteúdo, passe state.books para a LazyVerticalGrid.Fase 3: Navegação e Interatividade•Passo 3.1: Configurar a Navegação:•[ ] Crie uma rota para a tela de detalhes: bookDetail/{bookId}.•[ ] Crie um Composable vazio BookDetailScreen e adicione-o ao seu NavHost.•(Pergunta para o Gem: "Como passo o bookId do HomeScreen para o BookDetailScreen usando Navigation Compose?")•Passo 3.2: Implementar o Clique:•[ ] No AlbumCardItem dentro da LazyVerticalGrid, adicione um Modifier.clickable.•[ ] No clique, chame a função de navegação (navController.navigate("bookDetail/${book.id}")).Como usar este guia:1.Copie e cole a "Parte 1" para dar o contexto inicial ao seu Gem.2.Use a "Parte 2" como seu plano de ação. Vá item por item.3.Quando encontrar um desafio, faça uma pergunta específica ao Gem, referenciando o passo em que você está. Por exemplo: "Estou no Passo 2.1 e preciso definir meu HomeState. Considerando o layout da minha HomeScreen e o JSON da API, qual seria uma estrutura de dados robusta para essa data class?"Este método focado e passo a passo transformará essa tarefa complexa em uma série de etapas gerenciáveis e claras. Bom desenvolvimento